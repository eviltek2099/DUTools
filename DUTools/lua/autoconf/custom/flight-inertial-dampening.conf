name: Inertial Dampening
slots:
  core:
    class: CoreUnit
  antigrav:
    class: AntiGravityGeneratorUnit
  gyro:
    class: GyroUnit
  container:
    class: FuelContainer
    select: all
handlers:
  unit:
    start:
      lua: |
        -- error handling code added by wrap.lua
        __wrap_lua__stopped = false
        __wrap_lua__stopOnError = false
        __wrap_lua__rethrowErrorAlways = false
        __wrap_lua__rethrowErrorIfStopped = true
        __wrap_lua__rethrowErrorIfNotDisplayed = true
        __wrap_lua__canDisplayErrorOnSystemScreen = false
        
        function __wrap_lua__error (message)
          if __wrap_lua__stopped then return end
        
          local unit = unit or self or {}
          local messageDisplayed = false
        
          for _, value in pairs(unit) do
            if type(value) == "table" and value.setCenteredText then -- value is a screen
              value.setCenteredText(message)
              messageDisplayed = true
            end
          end
        
          if not messageDisplayed and __wrap_lua__canDisplayErrorOnSystemScreen and __wrap_lua__currentHandler ~= "system flush()" and system then
            system.showScreen(1)
            system.setScreen(string.format([=[
              <div style="font-size: 0.9em; padding-bottom: 6px">
                <p>Unhandled Lua error. Event:</p>
                <div style="font-family: Consolas, monospace; padding-top: 6px">%s</div>
                <p>Error:</p>
                <div style="font-family: Consolas, monospace; padding-top: 6px">%s</div>
                <p>This message will be displayed until the script is restarted without errors. Logging out and in will also remove it.</p>
              </block>
            ]=], __wrap_lua__currentHandler, message))
        
            messageDisplayed = true
          end
        
          if __wrap_lua__stopOnError then
            __wrap_lua__stopped = true
          end
        
          if __wrap_lua__stopped and messageDisplayed and unit and unit.exit then
            unit.exit()
          end
        
          local shouldRethrowError =
            __wrap_lua__rethrowErrorAlways or
            __wrap_lua__rethrowErrorIfStopped and __wrap_lua__stopped or
            __wrap_lua__rethrowErrorIfNotDisplayed and not messageDisplayed
        
          if shouldRethrowError then
            error(message)
          end
        end
        
        local ok, message = pcall(function ()
          __wrap_lua__currentHandler = "unit start()"
        
        -- script code
        
        --------------------------------------------------------------------------------
        -- minified minified inertial dampening script begins
        -- sha256 hash: 26ce72fdb56366e8c0db5c92b46d23f94f4b4710af8e622b963f19cb3e831131
        --------------------------------------------------------------------------------
        do
        do
        local _ENV=_ENV
        package.preload["common.CoordinateConverter"]=function(...)
        _ENV=_ENV
        local N=table.unpack
        local function aS(q)
        q=q or {}
        local O=q.library or library
        local aT={0,0,0}
        local aU={0,0,0}
        local aV={0,0,0}
        local self={}
        function self.setAxesFromCore(A)
        aT=A.getConstructWorldOrientationRight()
        aU=A.getConstructWorldOrientationForward()
        aV=A.getConstructWorldOrientationUp()
        end
        function self.setAxesFromGyro(B)
        aT=B.worldRight()
        aU=B.worldForward()
        aV=B.worldUp()
        end
        function self.relWorldToRightForwardUp(P)
        if P.x then P={P:unpack()} end
        return O.systemResolution3(aT,aU,aV,P)
        end
        function self.rightForwardUpToRelWorld(Q)
        if Q.x then Q={Q:unpack()} end
        local aW,aX,aY=N(aT)
        local aZ,a0,a1=N(aU)
        local a2,a3,a4=N(aV)
        local a5,a6,a7=N(Q)
        local a8=(a5*aW)+(a6*aZ)+(a7*a2)
        local a9=(a5*aX)+(a6*a0)+(a7*a3)
        local a_=(a5*aY)+(a6*a1)+(a7*a4)
        return {a8,a9,a_}
        end
        return self
        end
        return {new=aS}
        end
        end
        do
        local _ENV=_ENV
        package.preload["common.Hal"]=function(...)
        _ENV=_ENV
        local R=require"common.utils.string.firstLetterToUpperCase"
        local S=require"common.utils.array.orderedInsert"
        local T=require"common.utils.string.wordsToCamelCase"
        local r=table.sort
        local self=self or unit or {}
        local U={slotNames={},elementType={},elementInSlot={},elementSlotName={},elements={}}
        local function ba(b)return b.setTimer and b.exit end
        local function bb(b)return b.getItemsMass end
        local function bc(b)return b.spawnNumberSticker end
        local function bd(b)return b.getNbKeys end
        local function be(b)return bc(b) and b.getConstructCrossSection end
        local function bf(b)return b.getState end
        local function bg(b)return b.getMaxThrust end
        local function bh(b)return b.worldUp end
        local function bi(b)return b.getEntries and b.getConstructWorldPos end
        local function bj(b)return b.setCenteredText and b.setRawHTML end
        local function bk(b)return b.getTime end
        local function bl(b)return b.systemResolution3 end
        local function bm(b)return bf(b) and not bg(b) and not bh(b) and not bj(b) end
        local bn={{predicate=ba,singular="control",plural="controls"},{predicate=bb,singular="container",plural="containers"},{predicate=bc,singular="core",plural="cores"},{predicate=bd,singular="databank",plural="databanks"},{predicate=be,singular="dynamic core",plural="dynamic cores"},{predicate=bf,singular="element with state",plural="elements with state"},{predicate=bg,singular="engine",plural="engines"},{predicate=bh,singular="gyro",plural="gyros"},{predicate=bi,singular="radar",plural="radars"},{predicate=bj,singular="screen",plural="screens"},{predicate=bk,singular="system",plural="systems"},{predicate=bl,singular="library",plural="libraries"},{predicate=bm,singular="maybe pressable element",plural="maybe pressable elements"}}
        for a,C in pairs(bn) do
        C.singularCamelCase=T(C.singular)
        C.singularPascalCase=R(C.singularCamelCase)
        C.pluralCamelCase=T(C.plural)
        C.pluralPascalCase=R(C.pluralCamelCase)
        C.typeName=C.singularCamelCase
        C.tableName=C.pluralCamelCase
        C.requireOneFunctionName="require"..C.singularPascalCase
        C.requireAtLeastOneFunctionName="require"..C.pluralPascalCase
        C.requireOneErrorMessage=R(C.singular).." is not connected."
        C.requireAtLeastOneErrorMessage="No "..C.plural.." are connected."
        end
        for a,C in pairs(bn) do
        U[C.requireOneFunctionName]=function()return U[C.tableName][1] or error(C.requireOneErrorMessage) end
        U[C.requireAtLeastOneFunctionName]=function()
        local bo=U[C.tableName]
        if #bo<1 then error(C.requireAtLeastOneErrorMessage) end
        return bo
        end
        end
        local bp={}
        for h,f in pairs(self) do if type(h)=="string" and type(f)=="table" and type(f.export)=="table" then
        local bq,b=h,f
        U.slotNames[#U.slotNames+1]=bq
        U.elementInSlot[bq]=b
        U.elementSlotName[b]=bq
        bp[#bp+1]=b
        end end
        r(U.slotNames)
        for a,b in ipairs(bp) do S(U.elements,U.elementSlotName,b) end
        for a,C in ipairs(bn) do
        local br={}
        local bs=C.predicate
        U[C.tableName]=br
        for a,b in ipairs(U.elements) do if bs(b) then
        br[#br+1]=b
        U.elementType[b]=C.typeName
        end end
        end
        return U
        end
        end
        do
        local _ENV=_ENV
        package.preload["common.StringSectioner"]=function(...)
        _ENV=_ENV
        local s,V,r=table.concat,table.remove,table.sort
        local function bt()
        local l={contentChanged=false}
        local bu={}
        local function bv(bw)
        for D,t in ipairs(bu) do if t==bw then return D end end
        return nil
        end
        local function bx()if #bu==0 then return 1 else return bu[#bu].getOrder()+1 end end
        local function by()r(bu,function(bz,bA)return bz.getOrder()<bA.getOrder() end) end
        function l.createSection(c)
        c=c or {}
        local W=c.content or ""
        local X=c.order or bx()
        local bB=false
        assert(type(c)=="table","options must be nil or a dictionary-like table")
        assert(type(W)=="string","options.content must be string or nil")
        assert(type(X)=="number","options.order must be number or nil")
        if #W>0 then l.contentChanged=true end
        local t={}
        function t.getContent()return W end
        function t.getOrder()return X end
        function t.setContent(bC)
        assert(type(bC)=="string","newContent must be string")
        if W~=bC then
        W=bC
        if not bB then l.contentChanged=true end
        end
        end
        function t.setOrder(bD)
        assert(type(bD)=="number","newOrder must be a number")
        if X~=bD then if not bB then
        X=bD
        by()
        l.contentChanged=true
        end end
        end
        function t.unregister()
        local D=bv(t)
        if D then
        V(bu,D)
        bB=true
        l.contentChanged=true
        end
        end
        bu[#bu+1]=t
        by()
        return t
        end
        function l.getContent()
        local bE=#bu
        if bE==0 then return "" elseif bE==1 then return bu[1].getContent() else
        local u={}
        for D=1,bE do u[#u+1]=bu[D].getContent() end
        return s(u)
        end
        end
        function l.getContentWrappedInDiv()return "<div>"..l.getContent().."</div>" end
        return l
        end
        local function bF(Y)
        Y=tostring(Y)
        _stringSectioners=_stringSectioners or {}
        local l=_stringSectioners[Y]
        if l then return l end
        l=bt()
        _stringSectioners[Y]=l
        return l
        end
        return {getInstance=bF}
        end
        end
        do
        local _ENV=_ENV
        package.preload["common.Switcher"]=function(...)
        _ENV=_ENV
        local function bG(g,bH)
        local self={}
        local E=1
        function self.switchToNext()if E==#g then self.switchTo(1) else self.switchTo(E+1) end end
        function self.switchToPrevious()if E==1 then self.switchTo(#g) else self.switchTo(E-1) end end
        function self.switchTo(bI)
        local bJ=E
        E=bI
        if bH then bH(g[E],g[bJ]) end
        end
        function self.getIndex()return E end
        function self.getCurrent()return g[E] end
        return self
        end
        return {new=bG}
        end
        end
        do
        local _ENV=_ENV
        package.preload["common.SystemTimer"]=function(...)
        _ENV=_ENV
        local bK=require"common.getNextTimerId"
        local function bL(Z,bM)
        local self={ticked=false}
        local bN
        function self.isActive()return (bN and true) or false end
        function self.activate()if not bN then
        bN=bK()
        unit.setTimer(bN,Z)
        end end
        function self.deactivate()if bN then
        unit.stopTimer(bN)
        bN=nil
        end end
        function self.toggle()if self.isActive() then self.deactivate() else self.activate() end end
        function self.onStart()if not bM then self.activate() end end
        function self.onStop()self.deactivate() end
        function self.onTick(bO)if tostring(bO)==tostring(bN) then self.ticked=true end end
        return self
        end
        return {new=bL}
        end
        end
        do
        local _ENV=_ENV
        package.preload["common.data.elements"]=function(...)
        _ENV=_ENV
        return {{class="FuelContainer",name="Atmospheric Fuel Tank XS",fuel="Nitron",selfMass=8.866,maxItemsMass=200,volumeL=250},{class="FuelContainer",name="Atmospheric Fuel Tank S",fuel="Nitron",selfMass=38.3395662,maxItemsMass=800,volumeL=1000},{class="FuelContainer",name="Atmospheric Fuel Tank M",fuel="Nitron",selfMass=308.5606979,maxItemsMass=6400,volumeL=8000},{class="FuelContainer",name="Atmospheric Fuel Tank L",fuel="Nitron",selfMass=2453.7359041,maxItemsMass=51200,volumeL=64000},{class="FuelContainer",name="Space Fuel Tank S",fuel="Kergon",selfMass=38.0760445,maxItemsMass=1750,volumeL=1000},{class="FuelContainer",name="Space Fuel Tank M",fuel="Kergon",selfMass=304.6086784,maxItemsMass=14000,volumeL=8000},{class="FuelContainer",name="Space Fuel Tank L",fuel="Kergon",selfMass=2436.8703944,maxItemsMass=112000,volumeL=64000},{class="FuelContainer",name="Rocket Fuel Tank XS",fuel="Xeron",selfMass=2085.436,maxItemsMass=2000,volumeL=2000},{class="FuelContainer",name="Rocket Fuel Tank S",fuel="Xeron",selfMass=174.499,maxItemsMass=4000,volumeL=4000},{class="FuelContainer",name="Rocket Fuel Tank M",fuel="Xeron",selfMass=15486.081,maxItemsMass=32000,volumeL=32000},{class="FuelContainer",name="Rocket Fuel Tank L",fuel="Xeron",selfMass=1508.429,maxItemsMass=250000,volumeL=250000}}
        end
        end
        do
        local _ENV=_ENV
        package.preload["common.getNextTimerId"]=function(...)
        _ENV=_ENV
        if _timerIdCounter then return _timerIdCounter end
        local bP=require"common.utils.makeCounter"
        local bQ=(((__sessionId or math.random(0,999999999))%2000000000)//10000)*10000
        _timerIdCounter=bP(bQ)
        return function()return tostring(_timerIdCounter()) end
        end
        end
        do
        local _ENV=_ENV
        package.preload["common.utils.array.filter"]=function(...)
        _ENV=_ENV
        return function(aa,v)
        local i={}
        for a,f in ipairs(aa) do if v(f) then i[#i+1]=f end end
        return i
        end
        end
        end
        do
        local _ENV=_ENV
        package.preload["common.utils.array.findOne"]=function(...)
        _ENV=_ENV
        local function ab(g,v)for a,e in ipairs(g) do if v(e) then return e end end end
        return ab
        end
        end
        do
        local _ENV=_ENV
        package.preload["common.utils.array.map"]=function(...)
        _ENV=_ENV
        local function F(bR,bS)
        local bT={}
        for E,f in ipairs(bR) do bT[E]=bS(f) end
        return bT
        end
        return F
        end
        end
        do
        local _ENV=_ENV
        package.preload["common.utils.array.orderedInsert"]=function(...)
        _ENV=_ENV
        local w=string.format
        local G=table.insert
        local function S(aa,bU,bV)
        if #aa==0 then
        aa[1]=bV
        return 1
        end
        local bW=bU[bV]
        if not bW then error(w("value to be inserted (%s) is not in the weights table",bV)) end
        for x=1,#aa do
        local bX=aa[x]
        local bY=bU[bX]
        if not bY then error(w("value at index %d (%s) is not in the weights table",x,bX)) end
        if bY>bW then
        G(aa,x,bV)
        return x
        end
        end
        aa[#aa+1]=bV
        return #aa
        end
        return S
        end
        end
        do
        local _ENV=_ENV
        package.preload["common.utils.array.removeAllMatching"]=function(...)
        _ENV=_ENV
        local ac=require"common.utils.array.removeOneMatching"
        local function ad(g,v)
        local bZ
        local b0={}
        repeat
        bZ=false
        local e=ac(g,v)
        if e then
        bZ=true
        b0[#b0+1]=e
        end
        until not bZ
        return b0
        end
        return ad
        end
        end
        do
        local _ENV=_ENV
        package.preload["common.utils.array.removeOneMatching"]=function(...)
        _ENV=_ENV
        local V=table.remove
        local function ac(g,v)for E,e in ipairs(g) do if v(e) then return V(g,E) end end end
        return ac
        end
        end
        do
        local _ENV=_ENV
        package.preload["common.utils.formatDecimal"]=function(...)
        _ENV=_ENV
        local w=string.format
        local b1=string.match
        local function ae(b2,b3)
        local b4=w("%%.%df",b3)
        local b5=w(b4,b2)
        if b3<2 then return b5 end
        return b1(b5,"^([^.]*...-)0*$")
        end
        return ae
        end
        end
        do
        local _ENV=_ENV
        package.preload["common.utils.makeCounter"]=function(...)
        _ENV=_ENV
        return function(b6)
        b6=b6 or 0
        assert(type(b6)=="number","startValue must be a number")
        local f=b6
        return function()
        local b7=f
        f=f+1
        return b7
        end
        end
        end
        end
        do
        local _ENV=_ENV
        package.preload["common.utils.string.firstLetterToUpperCase"]=function(...)
        _ENV=_ENV
        local function R(af)
        local i=af:gsub("^%l",function(ag)return ag:upper() end)
        return i
        end
        return R
        end
        end
        do
        local _ENV=_ENV
        package.preload["common.utils.string.wordsToCamelCase"]=function(...)
        _ENV=_ENV
        local function T(af)
        local b8=af:lower():gsub("[^%a%d ]"," "):gsub(" +"," ")
        local i=b8:gsub(" (.)",function(ag)return ag:upper() end)
        return i
        end
        return T
        end
        end
        do
        local _ENV=_ENV
        package.preload["common.utils.table.asClosureBasedObject"]=function(...)
        _ENV=_ENV
        local function ah(b9)
        local self={}
        function self.__index(m,h)
        local f=b9[h]
        if type(f)~="function" then return f end
        return function(...)return f(b9,...) end
        end
        function self.__newindex(m,h,f)if type(f)~="function" then b9[h]=f else b9[h]=function(b_,...)return f(...) end end end
        return setmetatable(self,self)
        end
        return ah
        end
        end
        do
        local _ENV=_ENV
        package.preload["common.utils.table.countGroupsBy"]=function(...)
        _ENV=_ENV
        local function ai(g,ca)
        local cb={}
        for a,e in pairs(g) do
        local n=ca(e)
        if n then cb[n]=(cb[n] or 0)+1 end
        end
        return cb
        end
        return ai
        end
        end
        do
        local _ENV=_ENV
        package.preload["common.utils.table.getMaxValueKey"]=function(...)
        _ENV=_ENV
        local function aj(y)
        local cc,cd
        for h,f in pairs(y) do if not cc or f>cc then
        cc=f
        cd=h
        end end
        return cd,cc
        end
        return aj
        end
        end
        do
        local _ENV=_ENV
        package.preload["common.utils.table.getValueKey"]=function(...)
        _ENV=_ENV
        return function(y,ce)
        for h,f in pairs(y) do if f==ce then return h end end
        return nil
        end
        end
        end
        do
        local _ENV=_ENV
        package.preload["common.utils.table.toDictionary"]=function(...)
        _ENV=_ENV
        return function(y,cf,cg)
        assert(type(y)=="table","tbl must be table")
        assert(type(cf)=="function","getKey must be a function")
        assert(type(cg)=="function","getValue must be a function")
        local i={}
        for a,ch in pairs(y) do
        local ci=cf(ch)
        local cj=cg(ch)
        i[ci]=cj
        end
        return i
        end
        end
        end
        do
        local _ENV=_ENV
        package.preload["pilot.CommandMenu"]=function(...)
        _ENV=_ENV
        local ai=require"common.utils.table.countGroupsBy"
        local ck=require"common.utils.array.filter"
        local aj=require"common.utils.table.getMaxValueKey"
        local ak=require"common.utils.table.getValueKey"
        local F=require"common.utils.array.map"
        local ad=require"common.utils.array.removeAllMatching"
        local cl=math.floor
        local G,r,N=table.insert,table.sort,table.unpack
        local cm={"option1","option2","option3","option4","option5","option6","option7","option8","option9"}
        local function cn(d)
        local al=d.text
        return (type(al)=="function" and al()) or al
        end
        local function co(am)return function(cp,cq)
        local cr=cp.order
        local cs=cq.order
        if cr~=cs then return cr<cs end
        local ct=ak(am,cp)
        local cu=ak(am,cq)
        return ct<cu
        end end
        local function cv()
        local cw=#cm
        local cx
        return function(cy,an)
        local cz=cl(cy)
        if cx and cz<=cx then cz=cx+1 end
        local cA=cw-cz
        while an>cA do
        cz=cz-1
        cA=cw-cz
        end
        cx=cz
        return cm[cz]
        end
        end
        local function cB(c)
        local al=c.text
        assert(type(al=="string") or type(al=="function"),"options.text must be string or function")
        local X=c.order
        assert(type(X)=="number","options.order must be number")
        assert(X>=1,"options.order must be at least 1")
        assert(X<10,"options.order must be less than 10")
        local n=c.group
        assert(not n or type(n=="table","options.group must be array-like table or nil"))
        local ao=c.callback
        assert(not ao or type(ao)=="function","options.callback must be function or nil")
        local ap
        local aq
        local function cC()if ap.onTextChanged then ap.onTextChanged() end end
        ap={text=al,order=X,group=n,callback=ao and function()ao(aq) end}
        aq={setText=function(ar)
        assert(type(ar=="string") or type(ar=="function"),"newText must be string or function")
        ap.text=ar
        cC()
        end,refreshText=function()
        assert(type(ap.text)=="function","refreshText can only be called when command text is a function")
        cC()
        end}
        return ap,aq
        end
        local function cD(c)
        assert(type(c)=="table","options must be table")
        local as=c.setItemsChanged
        assert(type(as)=="function","options.setItemsChanged must be function")
        local cE=c.switchToLevel
        assert(type(cE)=="function","options.switchToLevel must be function")
        local cF=c.groupTextIndex
        assert(type(cF)=="number","options.groupTextIndex must be number")
        local g
        local am={}
        local self={}
        local cG={text="Back",order=9.99,callback=function()cE(self) end,isAutoAdded=true}
        local function cH(d)return d.group and d.group[cF] end
        local function cI(cJ)
        if #cJ<1 then return nil end
        local cK=cH(cJ[1])
        for at=2,#cJ do if cH(cJ[at])~=cK then return false end end
        return true
        end
        local function cL(cM)
        local au=cD{setItemsChanged=as,switchToLevel=cE,groupTextIndex=cF+1}
        au.addCommands(cM)
        au.addCommand(cG)
        return au
        end
        local function cN(cO)
        if #cO<=#cm then return cO end
        local i={N(cO)}
        local cP
        while true do
        local cQ=ck(cO,function(d)return not d.isAutoAdded end)
        if cI(cQ) then if cQ[cF].group[cF] then cF=cF+1 else error("Command pagination is not implemented.") end else break end
        end
        while true do
        local cR=ai(i,cH)
        local cS,cT=aj(cR)
        local cU=not cS or cT<=1 or (#i<=#cm and cT<cP)
        if cU then break end
        local cV=ad(i,function(d)return cH(d)==cS end)
        local au=cL(cV)
        G(i,{text=cS,order=cV[1].order,callback=function()cE(au) end})
        cP=cT
        end
        r(i,co(i))
        return i
        end
        local function cW()
        g={}
        local cX=cN(am)
        r(cX,co(cX))
        local cY=#cX
        local cZ=cv()
        for at=1,cY do
        local d=cX[at]
        local an=cY-at
        local j=cZ(d.order,an)
        local e={text=cn(d),callback=d.callback,action=j}
        d.onTextChanged=function()
        local ar=cn(d)
        if e.text~=ar then
        e.text=ar
        as()
        end
        end
        g[at]=e
        end
        end
        function self.addCommand(c0)
        G(am,c0)
        g=nil
        end
        function self.addCommands(c1)
        assert(type(c1)=="table","commandsToAdd must be array-like table")
        for a,d in ipairs(c1) do self.addCommand(d) end
        end
        function self.getItems()
        if not g then cW() end
        return g
        end
        return self
        end
        local function c2()
        local self={itemsChanged=true}
        local c3,c4
        local function as()self.itemsChanged=true end
        local function c5(c6)
        c4=c6
        self.itemsChanged=true
        end
        c3=cD{groupTextIndex=1,setItemsChanged=as,switchToLevel=c5}
        c4=c3
        function self.addCommand(av)
        local ap,aq=cB(av)
        c3.addCommand(ap)
        return aq
        end
        function self.addCommands(c7)
        assert(type(c7)=="table","commands must be array-like table")
        return F(c7,function(av)return self.addCommand(av) end)
        end
        function self.getItems()return c4.getItems() end
        return self
        end
        local function c8(Y)
        Y=tostring(Y)
        _commandMenus=_commandMenus or {}
        local H=_commandMenus[Y]
        if H then return H end
        _commandMenus[Y]=c2()
        return _commandMenus[Y]
        end
        return {new=c2,getInstance=c8}
        end
        end
        do
        local _ENV=_ENV
        package.preload["pilot.components.CommandMenuComponent"]=function(...)
        _ENV=_ENV
        local c9=require"common.utils.table.toDictionary"
        local aw=require"pilot.CommandMenu"
        local I=require"common.StringSectioner"
        local c_=require"pilot.views.hud.command-menu"
        local function da()
        local self={}
        local H=aw.getInstance("root")
        local db
        local l=I.getInstance("screen")
        local t
        local function dc(j)
        local dd=system.getActionKeyName(j)
        if not dd then return "???" else return dd:gsub("Left Alt","Alt") end
        end
        local function de()return H.itemsChanged end
        local function ax()
        local g=H.getItems()
        db=c9(g,function(e)return e.action end,function(e)return e.callback end)
        t.setContent(c_{items=g,getActionKeyName=dc})
        H.itemsChanged=false
        end
        function self.onStart()
        t=l.createSection{order=800}
        ax()
        end
        function self.onUpdate()if de() then ax() end end
        function self.onStop()t.unregister() end
        function self.onActionStart(j)
        if H.itemsChanged or not db then return false end
        local ao=db[j]
        if not ao then return false else
        ao()
        return true
        end
        end
        return self
        end
        return {new=da}
        end
        end
        do
        local _ENV=_ENV
        package.preload["pilot.components.CompositeComponent"]=function(...)
        _ENV=_ENV
        local function df(dg)
        assert(type(dg)=="table","components must be table")
        local self={}
        setmetatable(self,self)
        self.__index=function(y,h)
        local function dh(...)for x=1,#dg do
        local di=dg[x][h]
        if di then di(...) end
        end end
        y[h]=dh
        return dh
        end
        return self
        end
        return {new=df}
        end
        end
        do
        local _ENV=_ENV
        package.preload["pilot.components.FuelDisplay"]=function(...)
        _ENV=_ENV
        local dj=require"common.data.elements"
        local ab=require"common.utils.array.findOne"
        local dk=require"pilot.views.hud.readout"
        local F=require"common.utils.array.map"
        local dl=require"pilot.components.UpdatingDisplayComponent"
        local dm=math.abs
        local w=string.format
        local function dn(ay)
        local dp=ay.getSelfMass()
        return ab(dj,function(dq)return dq.class=="FuelContainer" and dm(dq.selfMass-dp)<epsilon end)
        end
        local function dr(J,az)return F(az,function(ay)
        local ds=dn(ay) or {}
        return {element=ay,fuel=ds.fuel,maxItemsMass=ds.maxItemsMass,itemsMass=ay.getItemsMass(),itemsMassTimestamp=J()}
        end) end
        local function dt(J,K)
        local du=false
        for x=1,#K do
        local aA=K[x]
        local dv=aA.element.getItemsMass()
        if dv~=aA.itemsMass then
        du=true
        aA.prevItemsMass=aA.itemsMass
        aA.prevItemsMassTimestamp=aA.itemsMassTimestmap
        aA.itemsMass=dv
        aA.itemsMassTimestamp=J()
        end
        end
        return du
        end
        local function aB(K)
        local g={}
        for x=1,#K do
        local aA=K[x]
        local dw=aA.maxItemsMass and (aA.itemsMass/aA.maxItemsMass)*100
        g[#g+1]={display=aA.fuel or "Unknown",value=w("%.1f",dw or aA.itemsMass),units=(dw and "%") or "kg"}
        end
        return {{display="Fuel tanks",items=g}}
        end
        local function dx(c)
        c=c or {}
        local az=c.fuelTanks or {}
        local L=c.system or system
        local J=L.getTime
        local K=dr(J,az)
        local dy
        function c.getContent()
        if #K<1 then return "" end
        if not dt(J,K) and dy then return dy end
        local W=dk{itemLabelBold=false,itemValueInline=true,groups=aB(K)}
        dy=W
        return W
        end
        return dl.new(c)
        end
        return {new=dx}
        end
        end
        do
        local _ENV=_ENV
        package.preload["pilot.components.SystemScreenComponent"]=function(...)
        _ENV=_ENV
        local I=require"common.StringSectioner"
        local function dz()
        local l=I.getInstance("screen")
        local self={}
        local dA=false
        function self.onStop()system.showScreen(0) end
        function self.onUpdate()if l.contentChanged then
        if not dA then
        system.showScreen(1)
        dA=true
        end
        system.setScreen(l.getContentWrappedInDiv())
        l.contentChanged=false
        end end
        return self
        end
        return {new=dz}
        end
        end
        do
        local _ENV=_ENV
        package.preload["pilot.components.UpdatingDisplayComponent"]=function(...)
        _ENV=_ENV
        local aC=require"pilot.components.CompositeComponent"
        local I=require"common.StringSectioner"
        local dB=require"common.SystemTimer"
        local function dC(c)
        c=c or {}
        assert(type(c)=="table","options must be table or nil")
        local Z=c.timerPeriod or 1
        assert(type(Z)=="number","options.timerPeriod must be number or nil")
        local dD=c.isDisplayed or false
        assert(type(dD)=="boolean","options.isDisplayed must be boolean or nil")
        local dE=c.getContent
        assert(type(dE)=="function","options.getContent must be function")
        local dF=c.shouldGetContentInFlush or false
        assert(type(dF)=="boolean","options.shouldGetContentInFlush must be boolean or nil")
        local l=I.getInstance("screen")
        local t
        local dG=dB.new(Z,dD)
        local function ax()t.setContent(dE()) end
        local self=aC.new{dG}
        local dH=self.onStart
        local dI=self.onStop
        local dJ=self.onUpdate
        local dK=self.onFlush
        function self.toggle()
        dD=not dD
        if dD then
        ax()
        dG.activate()
         else
        t.setContent""
        dG.deactivate()
        end
        end
        function self.onStart()
        dH()
        t=l.createSection{order=430}
        if dD then
        ax()
        dG.activate()
        end
        end
        function self.onStop()
        dI()
        t.unregister()
        end
        if dF then function self.onFlush()
        dK()
        if dD and dG.ticked then
        ax()
        dG.ticked=false
        end
        end else function self.onUpdate()
        dJ()
        if dD and dG.ticked then
        ax()
        dG.ticked=false
        end
        end end
        return self
        end
        return {new=dC}
        end
        end
        do
        local _ENV=_ENV
        package.preload["pilot.views.hud.command-menu"]=function(...)
        _ENV=_ENV
        local s=table.concat
        return function(q)
        local g=q.items
        local dL=q.getActionKeyName
        local u={}
        u[#u+1]=[[
        <div style="font-size: 0.85em; margin: 6px 0px 6px 5px; width: 200px">
        ]]
        for aD=1,#g do
        local e=g[aD]
        u[#u+1]=[[
        <div>
        []]..dL(e.action)..[[] ]]..e.text..[[
        </div>
        ]]
        end
        u[#u+1]=[[
        </div>
        ]]
        return s(u)
        end
        end
        end
        do
        local _ENV=_ENV
        package.preload["pilot.views.hud.readout"]=function(...)
        _ENV=_ENV
        local s=table.concat
        return function(q)
        local dM=q.groups or {}
        local dN=((q.itemLabelBold==nil or q.itemLabelBold) and "bold") or "normal"
        local dO=(q.itemValueInline and "display: inline-block") or ""
        if q.items then dM[#dM+1]={items=q.items} end
        if #dM==0 then return "" end
        local u={[[
        <div style="font-size: 0.85em; width: 200px; padding: 0px 5px; white-space: nowrap; text-overflow: ellipsis;">
        ]]}
        for dP=1,#dM do
        local n=dM[dP]
        local dQ=n.display
        local dR=n.items or {}
        if dQ then u[#u+1]=[[
        <div style="font-weight: bold; padding: 2px 0px">
        ]]..dQ..[[
        </div>
        ]] end
        for aD=1,#dR do
        local e=dR[aD]
        local dS=e.display
        local dT=e.value
        local dU=e.units
        u[#u+1]=[[
        <div>
        <div style="font-weight: ]]..dN..[[;]]..dO..[[">
        ]]..(dS or "")..[[
        </div>
        <div style="]]..dO..[[">
        ]]..((dT~=nil and tostring(dT)) or "")..[[ ]]..((dT~=nil and dU) or "")..[[
        </div>
        </div>
        ]]
        end
        end
        u[#u+1]=[[
        </div>
        ]]
        return s(u)
        end
        end
        end
        do
        local _ENV=_ENV
        package.preload["pilot.views.screen.readout"]=function(...)
        _ENV=_ENV
        local s,G=table.concat,table.insert
        local dV=math.min
        return function(q)
        local u={}
        local dW=q.screenHeight or 100
        local dX=q.lineHeight or 1.2
        local dY=q.extraHeight or 1.01
        local dZ=q.firstColumnWidth or 30
        local d0=q.fontSize
        if not d0 then
        d0=16
        local d1=0
        for a,n in ipairs(q.groups) do d1=d1+1+#n.items end
        if d1>1 then d0=dW/d1/dX/dY end
        end
        local d2=q.maxFontSize or 4
        d0=dV(d0,d2)
        G(u,[[
        <style scoped>
        .readout-table {
        width: 100%;
        line-height: ]]..dX..[[;
        font-size: ]]..d0 ..[[vh;
        color: white;
        }
        .readout-table > div > div {
        padding: 0 0 0 1vw;
        display: inline-block;
        }
        .readout-table > div > div:first-child:not(:last-child) {
        width: ]]..dZ..[[%;
        white-space: nowrap;
        text-overflow: ellipsis;
        font-family: sans-serif;
        }
        .readout-table > div > div:only-child {
        font-style: italic;
        font-weight: bold;
        }
        </style>
        <div class="readout-table">
        ]])
        for a,n in ipairs(q.groups) do
        G(u,[[
        <div>
        <div>
        ]]..(n.display or "")..[[
        </div>
        </div>
        ]])
        for a,e in ipairs(n.items) do
        local d3=(e.value~=nil and ((e.formatter and e.formatter(e.value)) or tostring(e.value))) or ""
        G(u,[[
        <div>
        <div>
        ]]..(e.display or "")..[[
        </div>
        <div>
        ]]..d3 ..[[ ]]..((e.value~=nil and e.units) or "")..[[
        </div>
        </div>
        ]])
        end
        end
        G(u,'</div>')
        return s(u)
        end
        end
        end
        do
        local _ENV=_ENV
        package.preload["pilot2.ConstructState"]=function(...)
        _ENV=_ENV
        local function d4(d5)
        if not d5 then error("fn must be not be nil") end
        return function()return vec3(d5()) end
        end
        local aE={}
        function aE.new(c)
        c=c or {}
        local self=setmetatable({getters={}},aE)
        if c.control then self:addControlGetters(c.control) end
        if c.core then self:addCoreGetters(c.core) end
        if c.gyro then self:addGyroGetters(c.gyro) end
        if c.nav then self:addNavGetters(c.nav) end
        return self
        end
        function aE:addControlGetters(aF)
        local o=self.getters
        o.atmosphereDensity=aF.getAtmosphereDensity
        o.closestPlanetInfluence=aF.getClosestPlanetInfluence
        end
        function aE:addCoreGetters(A)
        local o=self.getters
        o.constructMass=A.getConstructMass
        o.constructIMass=A.getConstructIMass
        o.constructId=A.getConstructId
        o.constructWorldPos=d4(A.getConstructWorldPos)
        o.constructCrossSection=d4(A.getConstructCrossSection)
        o.maxKinematicsParameters=A.getMaxKinematicsParameters
        o.altitude=A.getAltitude
        o.g=A.g
        o.worldGravity=d4(A.getWorldGravity)
        o.worldVertical=d4(A.getWorldVertical)
        o.angularVelocity=d4(A.getAngularVelocity)
        o.worldAngularVelocity=d4(A.getWorldAngularVelocity)
        o.angularAcceleration=d4(A.getAngularAcceleration)
        o.worldAngularAcceleration=d4(A.getWorldAngularAcceleration)
        o.velocity=d4(A.getVelocity)
        o.worldVelocity=d4(A.getWorldVelocity)
        o.acceleration=d4(A.getAcceleration)
        o.worldAcceleration=d4(A.getWorldAcceleration)
        o.constructOrientationUp=d4(A.getConstructOrientationUp)
        o.constructOrientationRight=d4(A.getConstructOrientationRight)
        o.constructOrientationForward=d4(A.getConstructOrientationForward)
        o.constructWorldOrientationUp=d4(A.getConstructWorldOrientationUp)
        o.constructWorldOrientationRight=d4(A.getConstructWorldOrientationRight)
        o.constructWorldOrientationForward=d4(A.getConstructWorldOrientationForward)
        o.atmoFMaxPlus=function()return self.maxKinematicsParameters[1] end
        o.atmoFMaxMinus=function()return self.maxKinematicsParameters[2] end
        o.spaceFMaxPlus=function()return self.maxKinematicsParameters[3] end
        o.spaceFMaxMinus=function()return self.maxKinematicsParameters[4] end
        o.accelerationMagnitude=function()return self.worldAcceleration:len() end
        o.speed=function()return self.worldVelocity:len() end
        o.constructOrientationDown=function()return -self.constructOrientationUp end
        o.constructOrientationLeft=function()return -self.constructOrientationLeft end
        o.constructOrientationBackward=function()return -self.constrructOrientationForward end
        o.constructWorldOrientationDown=function()return -self.constructWorldOrientationUp end
        o.constructWorldOrientationLeft=function()return -self.constructWorldOrientationRight end
        o.constructWorldOrientationBackward=function()return -self.constructWorldOrientationForward end
        end
        function aE:addGyroGetters(B)
        local o=self.getters
        o.worldUp=d4(B.worldUp)
        o.worldForward=d4(B.worldForward)
        o.worldRight=d4(B.worldRight)
        o.worldDown=function()return -self.worldUp end
        o.worldBackward=function()return -self.worldForward end
        o.worldLeft=function()return -self.worldRight end
        end
        function aE:addNavGetters(p)
        local o=self.getters
        o.lift=function()return p.lift[1] end
        o.brake=function()return p.brake[1] end
        o.throttle=function()return p.thrustManager.throttle end
        end
        function aE:__index(h)
        local o=rawget(self,"getters")
        local d6=o[h]
        if not d6 then return rawget(aE,h) end
        local f=d6()
        self[h]=f
        return f
        end
        function aE:reset()for h,a in pairs(self) do if h~="getters" then self[h]=nil end end end
        return aE
        end
        end
        do
        local _ENV=_ENV
        package.preload["pilot2.applyCommonNavImprovements"]=function(...)
        _ENV=_ENV
        local aG=utils.map
        local function aH(p,d7)
        p.composeTiltingAngularAcceleration=function()return nullvector end
        p.upAcceleration=12
        local d8=p.getStabilizedTransform
        p.getStabilizedTransform=function(k,d9,d_)
        if k.control.getAtmosphereDensity()<epsilon then return vec3(k.orient.worldUp()),vec3(k.orient.worldRight()),vec3(k.orient.worldForward()) end
        if d7 and d7.isActive then d_=0 end
        return d8(k,d9,d_)
        end
        local function ea(eb)return aG(eb,0,100,10,100) end
        p.composeBrakingAcceleration=function(k,ec)
        if ec<epsilon then return nullvector end
        local ed=vec3(k.core.getWorldVelocity())
        local ee=ea(ed:len())
        return -ee*ed*ec
        end
        end
        return aH
        end
        end
        do
        local _ENV=_ENV
        package.preload["pilot2.flight-modes.EnhancedNavManagerMode"]=function(...)
        _ENV=_ENV
        local aE=require"pilot2.ConstructState"
        local ef=require"common.CoordinateConverter"
        local aI=require"pilot2.flight-modes.states.StrafeState"
        local aJ=require"pilot2.flight-modes.states.MouseRotationState"
        local aK=require"pilot2.flight-modes.NavManagerMode"
        local aL=aK
        local aM=setmetatable({},aL)
        aM.__index=aM
        function aM.new(c)
        local self=aL.new(c)
        setmetatable(self,aM)
        self.state=aE.new(c)
        self.coordinateConverter=ef.new(c)
        self.strafe=aI.new(c.strafe)
        self.mouseRotation=aJ.new(c.mouseRotation)
        self.liftUpAccelerationDisabled=c.liftUpAccelerationDisabled or false
        self.readoutData={}
        self.collectReadoutData=c.collectReadoutData or false
        return self
        end
        function aM:createNavManager()
        local p=aL.createNavManager(self)
        local eg=p.getYawInput
        local eh=p.getPitchInput
        local ei=p.getRollInput
        p.updateYawPitchRoll=function(k)
        eg(k)
        eh(k)
        ei(k)
        end
        p.getYawInput=function(k)
        local i=k.lastYaw
        if self.mouseRotation.isActive then i=i+self.mouseRotation.lastYawInput end
        return i
        end
        p.getPitchInput=function(k)
        local i=k.lastPitch
        if self.mouseRotation.isActive then i=i+self.mouseRotation.lastPitchInput end
        return i
        end
        p.getRollInput=function(k)
        if self.strafe.isActive then return 0 end
        return k.lastRoll
        end
        self.state:addNavGetters(p)
        return p
        end
        function aM:relWorldToRightForwardUp(P)return vec3(self.coordinateConverter.relWorldToRightForwardUp(P)) end
        function aM:rightForwardUpToRelWorld(Q)return vec3(self.coordinateConverter.rightForwardUpToRelWorld(Q)) end
        function aM:composeForwardAcceleration()return self.nav:composeForwardAcceleration(self.nav.thrustManager:getAccelerationCommand()) end
        function aM:composeLiftUpAcceleration()
        local ej=(self.liftUpAccelerationDisabled and nullvector) or self.state.worldGravity
        return (self.state.lift*self.nav.upAcceleration*self.state.constructWorldOrientationUp)-ej
        end
        function aM:composeStrafeAcceleration()
        if not self.strafe.isActive then return nullvector end
        return self.state.constructWorldOrientationRight*self.nav.lastRoll*self.strafe.acceleration
        end
        function aM.composeCorrectionAcceleration(m)return nullvector end
        function aM:composeBrakingAcceleration()return self.nav:composeBrakingAcceleration(self.nav:getBrakeInput()) end
        function aM:updateViewLock()
        local ek=(self.system.isViewLocked()==1 and true) or false
        local el=self.mouseRotation.isActive
        if ek and not el then self.system.lockView(0) elseif not ek and el then self.system.lockView(1) end
        end
        function aM:onBeforeFlush()
        self.state:reset()
        self.coordinateConverter.setAxesFromCore(self.core)
        self.mouseRotation:updateYaw(self.system.getMouseDeltaX())
        self.mouseRotation:updatePitch(self.system.getMouseDeltaY())
        self.nav:updateYawPitchRoll()
        self.state.strafe=(self.strafe.isActive and self.nav.roll[1]) or 0
        self.readoutData={}
        end
        function aM.onAfterFlush(m)end
        function aM:onFlush()
        self:onBeforeFlush()
        local em=self:composeForwardAcceleration()
        local en=self:composeLiftUpAcceleration()
        local eo=self:composeStrafeAcceleration()
        local ep=self:composeCorrectionAcceleration()
        local eq=em+en+eo+ep
        local aN=self:composeAngularAcceleration()
        local er=self:composeBrakingAcceleration()
        self.nav:setEngineCommand("vertical,horizontal,torque",eq,aN)
        self.nav:setEngineCommand("brake",er,nullvector)
        self.nav:setBoosterCommand("booster")
        if self.collectReadoutData then
        local z=self.readoutData
        z.forwardAcceleration=em
        z.liftAcceleration=en
        z.strafeAcceleration=eo
        z.correctionAcceleration=ep
        z.totalEngineAcceleration=eq
        z.angularAcceleration=aN
        z.brakingAcceleration=er
        end
        self:onAfterFlush()
        end
        function aM:onUpdate()
        aL.onUpdate(self)
        self:updateViewLock()
        end
        return aM
        end
        end
        do
        local _ENV=_ENV
        package.preload["pilot2.flight-modes.InertialDampeningFlightMode"]=function(...)
        _ENV=_ENV
        local aM=require"pilot2.flight-modes.EnhancedNavManagerMode"
        local es=math.max
        local et,aG=utils.clamp,utils.map
        local aL=aM
        local aO=setmetatable({},aL)
        aO.__index=aO
        function aO.new(c)
        local self=aL.new(c)
        setmetatable(self,aO)
        self.autobraking=c.autobraking
        self.inertialDampening=c.inertialDampening
        self.readoutData={}
        self.collectReadoutData=c.collectReadoutData
        return self
        end
        function aO:composeForwardAcceleration()
        if not self.state.targetForwardSpeed then return aL.composeForwardAcceleration(self) end
        return nullvector
        end
        function aO:getRfuVelocityError()
        local i=-self.state.rfuVelocity
        local eu=(self.state.strafe>epsilon and i.x<-epsilon) or (self.state.strafe<-epsilon and i.x>epsilon)
        local ev=(self.state.throttle>epsilon and i.y<-epsilon) or (self.state.throttle<-epsilon and i.y>epsilon)
        local ew=(self.state.lift>epsilon and i.z<-epsilon) or (self.state.lift<-epsilon and i.z>epsilon)
        if eu then i.x=0 end
        if ev then i.y=0 end
        if ew then i.z=0 end
        if self.state.targetForwardSpeed then i.y=self.state.targetForwardSpeed-self.state.rfuVelocity.y end
        if self.collectReadoutData then
        local z=self.readoutData
        z.ignoreXVelocityError=eu
        z.ignoreYVelocityError=ev
        z.ignoreZVelocityError=ew
        end
        return i
        end
        function aO.getCorrectionAccelerationComponent(m,ex,ey,ez,eA)
        if ex<ey and ex>-ey then return 0 end
        if ex>ez then return eA end
        if -ex>ez then return -eA end
        return aG(ex,0,ez,0,eA)
        end
        function aO:composeCorrectionAcceleration()
        if not self.inertialDampening.isActive then return aL.composeCorrectionAcceleration(self) end
        local eB=self.inertialDampening.minSpeedErrorToCorrect
        local eC=self.inertialDampening.minSpeedErrorForMaxAcceleration
        local eD=self.state.maxEngineAcceleration
        local eE=self:getCorrectionAccelerationComponent(self.state.rfuVelocityError.x,eB,eC,eD)
        local eF=self:getCorrectionAccelerationComponent(self.state.rfuVelocityError.y,eB,eC,eD)
        local eG=self:getCorrectionAccelerationComponent(self.state.rfuVelocityError.z,eB,eC,eD)
        return self:rightForwardUpToRelWorld({eE,eF,eG})
        end
        function aO:composeBrakingAcceleration()
        if not self.autobraking.isActive or self.state.brake>epsilon then return aL.composeBrakingAcceleration(self) end
        if self.state.speed<epsilon then return nullvector end
        local eH=-self.state.velocityError
        local eI=eH:len()
        if self.collectReadoutData then self.readoutData.rfuUselessVelocity=self:relWorldToRightForwardUp(eH) end
        if eI<self.autobraking.minUselessSpeed then return nullvector end
        local eJ=self.state.worldVelocity-eH
        local eK=eJ:len()
        local eL=eI/eK
        if self.collectReadoutData then
        self.readoutData.rfuUsefulVelocity=eJ and self:relWorldToRightForwardUp(eJ)
        self.readoutData.uselessToUsefulSpeedRatio=eL
        end
        local eM=eL>=self.autobraking.minUselessToUsefulSpeedRatio or (self.state.targetForwardSpeed and self.state.targetForwardSpeed<(self.state.rfuVelocity.y-self.autobraking.minUselessSpeed))
        if eM then return -eH/0.05 end
        return nullvector
        end
        function aO:getMaxEngineForce()if self.state.atmosphereDensity>0.9 then return es(self.state.atmoFMaxPlus,self.state.atmoFMaxMinus) elseif self.state.atmosphereDensity<epsilon then return es(self.state.spaceFMaxPlus,self.state.spaceFMaxMinus) else return es(self.state.atmoFMaxPlus,self.state.atmoFMaxMinus,self.state.spaceFMaxPlus,self.state.spaceFMaxMinus) end end
        function aO:onBeforeFlush()
        aL.onBeforeFlush(self)
        self.state.maxEngineAcceleration=self:getMaxEngineForce()/self.state.constructMass
        self.state.forwardSpeedControlActive=self.inertialDampening.isActive and self.state.atmosphereDensity<epsilon
        self.state.targetForwardSpeed=self.state.forwardSpeedControlActive and self.state.throttle*self.inertialDampening.maxSpeed
        self.state.rfuVelocity=self:relWorldToRightForwardUp(self.state.worldVelocity)
        self.state.rfuVelocityError=self:getRfuVelocityError()
        self.state.velocityError=self:rightForwardUpToRelWorld(self.state.rfuVelocityError)
        if self.previousMaxSpeed and self.inertialDampening.maxSpeed and self.previousMaxSpeed~=self.inertialDampening.maxSpeed then
        self.state.throttle=et((self.state.throttle*self.previousMaxSpeed)/self.inertialDampening.maxSpeed,-1,1)
        self.nav.thrustManager.throttle=self.state.throttle
        self.updateControlThrottle=true
        end
        end
        function aO:onAfterFlush()
        self.previousMaxSpeed=self.inertialDampening.maxSpeed
        if self.collectReadoutData then
        local z=self.readoutData
        z.rfuVelocity=self.state.rfuVelocity
        z.rfuVelocityError=self.state.rfuVelocityError
        z.rfuGravity=self:relWorldToRightForwardUp(self.state.worldGravity)
        z.rfuForwardAcceleration=self:relWorldToRightForwardUp(z.forwardAcceleration)
        z.rfuLiftAcceleration=self:relWorldToRightForwardUp(z.liftAcceleration)
        z.rfuStrafeAcceleration=self:relWorldToRightForwardUp(z.strafeAcceleration)
        z.rfuCorrectionAcceleration=self:relWorldToRightForwardUp(z.correctionAcceleration)
        z.rfuBrakingAcceleration=self:relWorldToRightForwardUp(z.brakingAcceleration)
        end
        end
        function aO:onUpdate()
        if self.updateControlThrottle then
        self.nav.thrustManager.control.setThrottle(self.nav.thrustManager.throttle)
        self.updateControlThrottle=false
        end
        aL.onUpdate(self)
        end
        return aO
        end
        end
        do
        local _ENV=_ENV
        package.preload["pilot2.flight-modes.NavManagerMode"]=function(...)
        _ENV=_ENV
        local aK={}
        aK.__index=aK
        function aK.new(c)
        local self={antigrav=c.antigrav,core=c.core,gyro=c.gyro,control=c.control,system=c.system,hovercraftMode=c.hovercraftMode or 0,containers=c.containers or {}}
        return setmetatable(self,aK)
        end
        function aK:createNavManager()
        local p=Navigator.new(self.system,self.core,self.control)
        p.hovercraftMode=self.hovercraftMode
        if p.hovercraftMode==1 then
        p.pitchRollAmplitude=0.5
        p.pitchStabVelocityStart=30
        p.pitchStabVelocityEnd=60
        p.rollStabVelocityStart=110
        p.rollStabVelocityEnd=150
         else
        p.pitchRollAmplitude=1
        p.pitchStabVelocityStart=10
        p.pitchStabVelocityEnd=30
        p.rollStabVelocityStart=110
        p.rollStabVelocityEnd=150
        end
        return p
        end
        function aK:onStart()
        if not self.nav then self.nav=self:createNavManager() end
        for a,aP in ipairs(self.containers) do aP.show() end
        if self.antigrav then self.antigrav.show() end
        if self.gyro then self.gyro.show() end
        self.core.show()
        end
        function aK:onStop()
        for a,aP in ipairs(self.containers) do aP.hide() end
        if self.antigrav then self.antigrav.hide() end
        if self.gyro then self.gyro.hide() end
        self.core.hide()
        end
        function aK:onActionStart(j)if j=="forward" then self.nav:decrease(self.nav.pitch) elseif j=="backward" then self.nav:increase(self.nav.pitch) elseif j=="right" then self.nav:increase(self.nav.roll) elseif j=="left" then self.nav:decrease(self.nav.roll) elseif j=="up" then self.nav:increase(self.nav.lift) elseif j=="down" then self.nav:decrease(self.nav.lift) elseif j=="yawright" then self.nav:decrease(self.nav.yaw) elseif j=="yawleft" then self.nav:increase(self.nav.yaw) elseif j=="brake" then self.nav:increase(self.nav.brake) elseif j=="stopengines" then self.nav.thrustManager:resetThrottle() elseif j=="booster" then self.nav:toggleBoosters() end end
        function aK:onActionLoop(j)if j=="speedup" then self.nav.thrustManager:updateCommand(0.05) elseif j=="speeddown" then self.nav.thrustManager:updateCommand(-0.05) end end
        function aK:onActionStop(j)if j=="forward" then self.nav:increase(self.nav.pitch) elseif j=="backward" then self.nav:decrease(self.nav.pitch) elseif j=="right" then self.nav:decrease(self.nav.roll) elseif j=="left" then self.nav:increase(self.nav.roll) elseif j=="up" then self.nav:decrease(self.nav.lift) elseif j=="down" then self.nav:increase(self.nav.lift) elseif j=="yawright" then self.nav:increase(self.nav.yaw) elseif j=="yawleft" then self.nav:decrease(self.nav.yaw) elseif j=="brake" then self.nav:decrease(self.nav.brake) end end
        function aK:onUpdate()self.nav:update() end
        function aK:composeAngularAcceleration()return self.nav:composeControlledStabAngularAcceleration(self.nav:getRollInput(),self.nav:getPitchInput())+self.nav:composeTiltingAngularAcceleration()+self.nav:composeTurningAngularAcceleration(self.nav:getYawInput()) end
        function aK:onFlush()
        local eN=self.nav:composeForwardAcceleration(self.nav.thrustManager:getAccelerationCommand())
        local aN=self:composeAngularAcceleration()
        self.nav:setEngineCommand("vertical,torque",self.nav:composeLiftUpAcceleration(self.nav:getLiftInput()),aN)
        self.nav:setEngineCommand("horizontal",eN,nullvector)
        self.nav:setEngineCommand("brake",self.nav:composeBrakingAcceleration(self.nav:getBrakeInput()),nullvector)
        self.nav:setBoosterCommand("booster")
        end
        return aK
        end
        end
        do
        local _ENV=_ENV
        package.preload["pilot2.flight-modes.states.MouseRotationState"]=function(...)
        _ENV=_ENV
        local aJ={}
        aJ.__index=aJ
        local eO=utils.lerp
        function aJ.new(c)
        c=c or {}
        local self={isActive=c.isActive or false,invertYaw=c.invertYaw or false,invertPitch=c.invertPitch or false,yawInertia=c.yawInertia or 0.15,yawSensitivity=c.yawSensitivity or 0.1,pitchInertia=c.pitchInertia or 0.1,pitchSensitivity=c.pitchSensitivity or 0.1,lastYawInput=0,lastPitchInput=0}
        return setmetatable(self,aJ)
        end
        function aJ:activate()
        if self.isActive then return end
        self.lastYawInput=0
        self.lastPitchInput=0
        self.isActive=true
        end
        function aJ:deactivate()
        if not self.isActive then return end
        self.isActive=false
        end
        function aJ:toggle()if self.isActive then self:deactivate() else self:activate() end end
        function aJ:updateYaw(eP)
        local eQ=eP*self.yawSensitivity*((self.invertYaw and 1) or -1)
        self.lastYawInput=eO(self.yawInertia,eQ,self.lastYawInput)
        end
        function aJ:updatePitch(eR)
        local eS=eR*self.pitchSensitivity*((self.invertPitch and 1) or -1)
        self.lastPitchInput=eO(self.pitchInertia,eS,self.lastPitchInput)
        end
        return aJ
        end
        end
        do
        local _ENV=_ENV
        package.preload["pilot2.flight-modes.states.StrafeState"]=function(...)
        _ENV=_ENV
        local aI={}
        aI.__index=aI
        function aI.new(c)
        c=c or {}
        local self={isActive=c.isActive or false,acceleration=c.acceleration or 10}
        return setmetatable(self,aI)
        end
        function aI:activate()
        if self.isActive then return end
        self.isActive=true
        end
        function aI:deactivate()
        if not self.isActive then return end
        self.isActive=false
        end
        function aI:toggle()if self.isActive then self:deactivate() else self:activate() end end
        return aI
        end
        end
        do
        local _ENV=_ENV
        package.preload["scripts.flight-inertial-dampening.InertialDampeningControl"]=function(...)
        _ENV=_ENV
        local ae=require"common.utils.formatDecimal"
        local eT=require"pilot.views.screen.readout"
        local ak=require"common.utils.table.getValueKey"
        local aw=require"pilot.CommandMenu"
        local eU=require"common.Switcher"
        local w=string.format
        local r=table.sort
        local eV=3.6
        local aQ=1/3.6
        local function eW(eX)
        local c={100*aQ,500*aQ,1000*aQ,5000*aQ,10000*aQ,29999*aQ}
        local eY=ak(c,eX)
        if not eY then
        c[#c+1]=eX
        r(c)
        eY=ak(c,eX)
        end
        return c,eY
        end
        local function aB(M)
        if not M.collectReadoutData then return {} end
        local z=M.readoutData
        return {{display="Inertial dampening flight mode",items={{display="Velocity (rfu)",value=z.rfuVelocity,units="m/s"},{display="Velocity error (rfu)",value=z.rfuVelocityError,units="m/s"},{display="Gravity (rfu)",value=z.rfuGravity,units="m/s2"},{display="Forward accel. (rfu)",value=z.rfuForwardAcceleration,units="m/s2"},{display="Lift acceleration (rfu)",value=z.rfuLiftAcceleration,units="m/s2"},{display="Strafe acceleration (rfu)",value=z.rfuStrafeAcceleration,units="m/s2"},{display="Correction acceleration (rfu)",value=z.rfuCorrectionAcceleration,units="m/s2"},{display="Useless velocity (rfu)",value=z.rfuUselessVelocity,units="m/s"},{display="Useful velocity (rfu)",value=z.rfuUsefulVelocity,units="m/s"},{display="Useless/useful speed",value=z.uselessToUsefulSpeedRatio and ae(z.uselessToUsefulSpeedRatio,3)},{display="Braking acceleration (rfu)",value=z.rfuBrakingAcceleration,units="m/s2"},{display="Ignore left/right vel. err.?",value=z.ignoreXVelocityError},{display="Ignore fwd/back vel. err.?",value=z.ignoreYVelocityError},{display="Ignore up/down vel. err.?",value=z.ignoreZVelocityError}}}}
        end
        local function eZ(c)
        local aR=c.screen
        local L=c.system or system
        local M=c.flightMode
        local e0=L.getActionKeyName("left")
        local e1=L.getActionKeyName("right")
        local e2,e3=eW(c.flightMode.inertialDampening.maxSpeed)
        local e4
        e4=eU.new(e2,function()M.inertialDampening.maxSpeed=e4.getCurrent() end)
        e4.switchTo(e3)
        local H=aw.getInstance("root")
        H.addCommands{{order=1,group={"Piloting..."},text=function()return w("Mouse rotation: %s",(M.mouseRotation.isActive and "ON") or "OFF") end,callback=function(d)
        M.mouseRotation:toggle()
        d.refreshText()
        end},{order=2,group={"Piloting..."},text=function()return w("%s and %s keys: %s",e0,e1,(M.strafe.isActive and "STRAFE") or "ROLL") end,callback=function(d)
        M.strafe:toggle()
        d.refreshText()
        end},{order=3,group={"Piloting..."},text=function()return w("Inertial dampening: %s",(M.inertialDampening.isActive and "ON") or "OFF") end,callback=function(d)
        M.inertialDampening.isActive=not M.inertialDampening.isActive
        d.refreshText()
        end},{order=4,group={"Piloting..."},text=function()return w("Auto-braking: %s",(M.autobraking.isActive and "ON") or "OFF") end,callback=function(d)
        M.autobraking.isActive=not M.autobraking.isActive
        d.refreshText()
        end},{order=5,group={"Piloting..."},text=function()return w("Max s. in space: %.0f km/h",M.inertialDampening.maxSpeed*eV) end,callback=function(d)
        e4.switchToNext()
        d.refreshText()
        end},{order=9,group={"Piloting..."},text=function()return w("Lift-up acceleration: %s",(M.liftUpAccelerationDisabled and "OFF") or "ON") end,callback=function(d)
        M.liftUpAccelerationDisabled=not M.liftUpAccelerationDisabled
        d.refreshText()
        end}}
        local self={}
        function self.onUpdate()
        if not aR then return end
        aR.setRawHTML(eT{groups=aB(M),firstColumnWidth=40})
        end
        return self
        end
        return {new=eZ}
        end
        end
        end
        __wrap_lua__stopOnError=true
        local aH=require"pilot2.applyCommonNavImprovements"
        local ah=require"common.utils.table.asClosureBasedObject"
        local e5=require"pilot.components.CommandMenuComponent"
        local aC=require"pilot.components.CompositeComponent"
        local e6=require"pilot.components.FuelDisplay"
        local U=require"common.Hal"
        local e7=require"scripts.flight-inertial-dampening.InertialDampeningControl"
        local aO=require"pilot2.flight-modes.InertialDampeningFlightMode"
        local e8=require"pilot.components.SystemScreenComponent"
        local aQ=1/3.6
        local A=U.requireDynamicCore()
        local B=U.gyros[1]
        local aF=U.requireControl()
        local L=U.requireSystem()
        local O=U.requireLibrary()
        local aR=U.screens[1]
        local e9=U.containers
        for a,e_ in pairs(U.screens) do e_.clear() end
        local M=ah(aO.new{core=A,gyro=B,control=aF,system=L,library=O,collectReadoutData=aR,mouseRotation={invertYaw=false,invertPitch=false,yawInertia=0.15,yawSensitivity=0.1,pitchInertia=0.1,pitchSensitivity=0.1},inertialDampening={isActive=true,maxSpeed=1000*aQ,minSpeedErrorToCorrect=5*aQ,minSpeedErrorForMaxAcceleration=10*aQ},autobraking={isActive=true,minUselessSpeed=0.1*aQ,minUselessToUsefulSpeedRatio=1}})
        local fa=M.createNavManager
        function M.createNavManager()
        local p=fa()
        p.thrustManager.throttleStep=0.05
        aH(p,M.mouseRotation)
        return p
        end
        script=aC.new{M,e6.new{isDisplayed=true,fuelTanks=e9,system=L},e7.new{flightMode=M,screen=aR,system=L},e5.new{system=L},e8.new()}
        script.onStart()
        __wrap_lua__stopOnError=false
        --------------------------------------------------------------------------------
        -- minified minified inertial dampening script ends
        --------------------------------------------------------------------------------
        
        
        -- error handling code added by wrap.lua
        end)
        if not ok then
          __wrap_lua__error(message)
          if not script then script = {} end
        end
    stop:
      lua: |
        if not __wrap_lua__stopped and script.onStop then
          __wrap_lua__currentHandler = "unit stop()"
          local ok, message = pcall(script.onStop,unit)
          if not ok then __wrap_lua__error(message) end
        end
    tick(timerId):
      lua: |
        if not __wrap_lua__stopped and script.onTick then
          __wrap_lua__currentHandler = "unit tick(timerId)"
          local ok, message = pcall(script.onTick,timerId,unit)
          if not ok then __wrap_lua__error(message) end
        end
  system:
    actionStart(action):
      lua: |
        if not __wrap_lua__stopped and script.onActionStart then
          __wrap_lua__currentHandler = "system actionStart(action)"
          local ok, message = pcall(script.onActionStart,action,system)
          if not ok then __wrap_lua__error(message) end
        end
    actionStop(action):
      lua: |
        if not __wrap_lua__stopped and script.onActionStop then
          __wrap_lua__currentHandler = "system actionStop(action)"
          local ok, message = pcall(script.onActionStop,action,system)
          if not ok then __wrap_lua__error(message) end
        end
    actionLoop(action):
      lua: |
        if not __wrap_lua__stopped and script.onActionLoop then
          __wrap_lua__currentHandler = "system actionLoop(action)"
          local ok, message = pcall(script.onActionLoop,action,system)
          if not ok then __wrap_lua__error(message) end
        end
    update:
      lua: |
        if not __wrap_lua__stopped and script.onUpdate then
          __wrap_lua__currentHandler = "system update()"
          local ok, message = pcall(script.onUpdate,system)
          if not ok then __wrap_lua__error(message) end
        end
    flush:
      lua: |
        if not __wrap_lua__stopped and script.onFlush then
          __wrap_lua__currentHandler = "system flush()"
          local ok, message = pcall(script.onFlush,system)
          if not ok then __wrap_lua__error(message) end
        end
